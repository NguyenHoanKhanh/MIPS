$date
	Sat Oct 04 14:34:06 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 32 ! p_o_pc [31:0] $end
$var wire 32 " p_wb_data [31:0] $end
$var reg 1 # p_clk $end
$var reg 1 $ p_i_ce $end
$var reg 1 % p_rst $end
$scope module p $end
$var wire 1 & c_d_o_ALUSrc $end
$var wire 1 ' c_d_o_Branch $end
$var wire 1 ( c_d_o_MemRead $end
$var wire 1 ) c_d_o_MemWrite $end
$var wire 1 * c_d_o_MemtoReg $end
$var wire 1 + c_d_o_RegDst $end
$var wire 1 , c_d_o_RegWrite $end
$var wire 6 - d_c_o_opcode [5:0] $end
$var wire 1 . p_clk $end
$var wire 1 / p_i_ce $end
$var wire 32 0 p_o_pc [31:0] $end
$var wire 1 1 p_rst $end
$var wire 32 2 p_wb_data [31:0] $end
$scope module d $end
$var wire 1 . d_clk $end
$var wire 1 & d_i_ALUSrc $end
$var wire 1 ( d_i_MemRead $end
$var wire 1 ) d_i_MemWrite $end
$var wire 1 * d_i_MemtoReg $end
$var wire 1 + d_i_RegDst $end
$var wire 1 , d_i_RegWrite $end
$var wire 1 / d_i_ce $end
$var wire 32 3 d_o_pc [31:0] $end
$var wire 1 1 d_rst $end
$var wire 1 4 ds_es_o_ce $end
$var wire 32 5 ds_es_o_data_rs [31:0] $end
$var wire 32 6 ds_es_o_data_rt [31:0] $end
$var wire 6 7 ds_es_o_funct [5:0] $end
$var wire 16 8 ds_es_o_imm [15:0] $end
$var wire 6 9 ds_es_o_opcode [5:0] $end
$var wire 32 : es_load_data [31:0] $end
$var wire 32 ; es_ms_alu_value [31:0] $end
$var wire 1 < es_ms_o_ce $end
$var wire 6 = es_o_funct [5:0] $end
$var wire 6 > es_o_opcode [5:0] $end
$var wire 1 ? es_o_zero $end
$var wire 1 @ fs_ds_o_ce $end
$var wire 32 A fs_ds_o_instr [31:0] $end
$var wire 32 B write_back_data [31:0] $end
$scope module is $end
$var wire 1 . f_clk $end
$var wire 1 C f_i_ack $end
$var wire 1 / f_i_ce $end
$var wire 32 D f_i_instr [31:0] $end
$var wire 1 E f_i_last $end
$var wire 1 1 f_rst $end
$var reg 1 F f_o_ce $end
$var reg 32 G f_o_instr [31:0] $end
$var reg 32 H f_o_pc [31:0] $end
$var reg 1 I f_o_syn $end
$scope module t $end
$var wire 1 . t_clk $end
$var wire 1 J t_i_syn $end
$var wire 1 1 t_rst $end
$var integer 32 K counter [31:0] $end
$var reg 1 L t_o_ack $end
$var reg 32 M t_o_instr [31:0] $end
$var reg 1 N t_o_last $end
$upscope $end
$upscope $end
$scope module ds $end
$var wire 5 O d_o_addr_rs [4:0] $end
$var wire 5 P d_o_addr_rt [4:0] $end
$var wire 1 . ds_clk $end
$var wire 5 Q ds_i_addr_rd [4:0] $end
$var wire 1 @ ds_i_ce $end
$var wire 32 R ds_i_data_rd [31:0] $end
$var wire 32 S ds_i_instr [31:0] $end
$var wire 1 + ds_i_reg_dst $end
$var wire 1 , ds_i_reg_wr $end
$var wire 1 4 ds_o_ce $end
$var wire 32 T ds_o_data_rs [31:0] $end
$var wire 32 U ds_o_data_rt [31:0] $end
$var wire 6 V ds_o_funct [5:0] $end
$var wire 16 W ds_o_imm [15:0] $end
$var wire 6 X ds_o_opcode [5:0] $end
$var wire 1 1 ds_rst $end
$var wire 5 Y write_register [4:0] $end
$scope module d $end
$var wire 1 . d_clk $end
$var wire 1 @ d_i_ce $end
$var wire 6 Z d_i_funct [5:0] $end
$var wire 32 [ d_i_instr [31:0] $end
$var wire 6 \ d_i_opcode [5:0] $end
$var wire 1 1 d_rst $end
$var wire 1 ] funct_add $end
$var wire 1 ^ funct_and $end
$var wire 1 _ funct_or $end
$var wire 1 ` funct_sub $end
$var wire 1 a funct_xor $end
$var wire 1 b op_addi $end
$var wire 1 c op_addiu $end
$var wire 1 d op_andi $end
$var wire 1 e op_branch $end
$var wire 1 f op_load $end
$var wire 1 g op_ori $end
$var wire 1 h op_rtype $end
$var wire 1 i op_slti $end
$var wire 1 j op_sltiu $end
$var wire 1 k op_store $end
$var wire 1 l op_xori $end
$var wire 32 m temp_instr [31:0] $end
$var reg 5 n d_o_addr_rd [4:0] $end
$var reg 5 o d_o_addr_rs [4:0] $end
$var reg 5 p d_o_addr_rt [4:0] $end
$var reg 1 q d_o_ce $end
$var reg 6 r d_o_funct [5:0] $end
$var reg 16 s d_o_imm [15:0] $end
$var reg 6 t d_o_opcode [5:0] $end
$upscope $end
$scope module r $end
$var wire 5 u r_addr_in [4:0] $end
$var wire 5 v r_addr_out1 [4:0] $end
$var wire 5 w r_addr_out2 [4:0] $end
$var wire 1 . r_clk $end
$var wire 32 x r_data_in [31:0] $end
$var wire 32 y r_data_out1 [31:0] $end
$var wire 32 z r_data_out2 [31:0] $end
$var wire 1 1 r_rst $end
$var wire 1 , r_wr_en $end
$var integer 32 { i [31:0] $end
$upscope $end
$upscope $end
$scope module es $end
$var wire 32 | alu_value [31:0] $end
$var wire 1 } done $end
$var wire 1 . es_clk $end
$var wire 6 ~ es_i_alu_funct [5:0] $end
$var wire 6 !" es_i_alu_op [5:0] $end
$var wire 1 & es_i_alu_src $end
$var wire 1 4 es_i_ce $end
$var wire 32 "" es_i_data_rs [31:0] $end
$var wire 32 #" es_i_data_rt [31:0] $end
$var wire 16 $" es_i_imm [15:0] $end
$var wire 32 %" es_imm [31:0] $end
$var wire 32 &" es_o_data_2 [31:0] $end
$var wire 1 1 es_rst $end
$var reg 4 '" alu_control [3:0] $end
$var reg 32 (" es_o_alu_value [31:0] $end
$var reg 1 )" es_o_ce $end
$var reg 6 *" es_o_funct [5:0] $end
$var reg 6 +" es_o_opcode [5:0] $end
$var reg 1 ," es_o_zero $end
$scope module a $end
$var wire 32 -" a_i_data_rs [31:0] $end
$var wire 32 ." a_i_data_rt [31:0] $end
$var wire 4 /" a_i_funct [3:0] $end
$var wire 1 0" funct_add $end
$var wire 1 1" funct_addu $end
$var wire 1 2" funct_and $end
$var wire 1 3" funct_eq $end
$var wire 1 4" funct_ge $end
$var wire 1 5" funct_geu $end
$var wire 1 6" funct_neq $end
$var wire 1 7" funct_or $end
$var wire 1 8" funct_sll $end
$var wire 1 9" funct_slt $end
$var wire 1 :" funct_sltu $end
$var wire 1 ;" funct_sra $end
$var wire 1 <" funct_srl $end
$var wire 1 =" funct_sub $end
$var wire 1 >" funct_xor $end
$var reg 32 ?" alu_value [31:0] $end
$var reg 1 @" done $end
$upscope $end
$upscope $end
$scope module m $end
$var wire 32 A" alu_value_addr [31:0] $end
$var wire 1 . m_clk $end
$var wire 1 < m_i_ce $end
$var wire 32 B" m_i_store_data [31:0] $end
$var wire 1 ( m_rd_en $end
$var wire 1 1 m_rst $end
$var wire 1 ) m_wr_en $end
$var integer 32 C" i [31:0] $end
$var reg 32 D" m_o_load_data [31:0] $end
$upscope $end
$upscope $end
$scope module c $end
$var wire 6 E" d_c_opcode [5:0] $end
$var reg 1 F" ALUSrc $end
$var reg 1 G" Branch $end
$var reg 1 H" MemRead $end
$var reg 1 I" MemWrite $end
$var reg 1 J" MemtoReg $end
$var reg 1 K" RegDst $end
$var reg 1 L" RegWrite $end
$upscope $end
$upscope $end
$scope task reset $end
$var integer 32 M" counter [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10 M"
1L"
1K"
0J"
0I"
0H"
0G"
0F"
b0 E"
b0 D"
b100000 C"
b0 B"
b0 A"
1@"
b0 ?"
0>"
0="
0<"
0;"
0:"
09"
08"
07"
06"
05"
04"
03"
02"
01"
10"
b0 /"
b0 ."
b0 -"
0,"
b0 +"
b0 *"
0)"
b0 ("
b0 '"
b0 &"
b0 %"
b0 $"
b0 #"
b0 ""
b0 !"
b0 ~
1}
b0 |
b100000 {
b0 z
b0 y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
0q
b0 p
b0 o
b0 n
b0 m
0l
0k
0j
0i
1h
0g
0f
0e
0d
0c
0b
0a
0`
0_
0^
0]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
0N
b0 M
0L
b0 K
0J
0I
b0 H
b0 G
0F
0E
b0 D
0C
b0 B
b0 A
0@
0?
b0 >
b0 =
0<
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
04
b0 3
b0 2
01
b0 0
x/
0.
b0 -
1,
1+
0*
0)
0(
0'
0&
0%
x$
0#
b0 "
b0 !
$end
#5
b100000 C"
b100000 {
1#
1.
#10
0#
0.
#15
1%
11
1#
1.
#20
0#
0.
#25
b100 H
b100 !
b100 0
b100 3
1I
1J
1$
1/
1#
1.
#30
0#
0.
#35
1L
1C
1N
1E
b10000110000100000100000 M
b10000110000100000100000 D
b1000 H
b1000 !
b1000 0
b1000 3
1#
1.
#40
0#
0.
#45
1]
b100000 Z
b1100 H
b1100 !
b1100 0
b1100 3
1F
1@
0I
0J
b10000110000100000100000 G
b10000110000100000100000 m
b10000110000100000100000 A
b10000110000100000100000 S
b10000110000100000100000 [
1#
1.
#50
0#
0.
#55
b1 Y
b1 u
b11 &"
b11 ."
b101 ?"
b101 |
1@"
1}
0N
0E
0L
0C
b10000 H
b10000 !
b10000 0
b10000 3
0I
0J
b100000 r
b100000 7
b100000 V
b100000 ~
b1 n
b1 Q
b11 p
b11 6
b11 U
b11 z
b11 #"
b11 B"
b11 P
b11 w
b10 o
b10 5
b10 T
b10 y
b10 ""
b10 -"
b10 O
b10 v
1q
14
1#
1.
#60
0#
0.
#65
b101 "
b101 2
b101 B
b101 R
b101 x
0)"
0<
b100000 *"
b100000 =
b101 ("
b101 ;
b101 A"
b10100 H
b10100 !
b10100 0
b10100 3
1I
1J
1#
1.
#70
0#
0.
#75
1L
1C
1N
1E
b11000 H
b11000 !
b11000 0
b11000 3
0)"
0<
1#
1.
