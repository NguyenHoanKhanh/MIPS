$date
	Sun Oct 05 22:36:44 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 32 ! es_o_alu_pc [31:0] $end
$var wire 32 " es_o_alu_value [31:0] $end
$var wire 1 # es_o_ce $end
$var wire 1 $ es_o_change_pc $end
$var wire 6 % es_o_funct [5:0] $end
$var wire 6 & es_o_opcode [5:0] $end
$var wire 1 ' es_o_zero $end
$var reg 1 ( es_clk $end
$var reg 6 ) es_i_alu_funct [5:0] $end
$var reg 6 * es_i_alu_op [5:0] $end
$var reg 1 + es_i_alu_src $end
$var reg 1 , es_i_branch $end
$var reg 1 - es_i_ce $end
$var reg 32 . es_i_data_rs [31:0] $end
$var reg 32 / es_i_data_rt [31:0] $end
$var reg 16 0 es_i_imm [15:0] $end
$var reg 32 1 es_i_pc [31:0] $end
$var reg 1 2 es_rst $end
$scope module es $end
$var wire 32 3 alu_pc [31:0] $end
$var wire 32 4 alu_value [31:0] $end
$var wire 1 5 done $end
$var wire 1 6 es_clk $end
$var wire 6 7 es_i_alu_funct [5:0] $end
$var wire 6 8 es_i_alu_op [5:0] $end
$var wire 1 9 es_i_alu_src $end
$var wire 1 : es_i_branch $end
$var wire 1 ; es_i_ce $end
$var wire 32 < es_i_data_rs [31:0] $end
$var wire 32 = es_i_data_rt [31:0] $end
$var wire 16 > es_i_imm [15:0] $end
$var wire 32 ? es_i_pc [31:0] $end
$var wire 1 @ es_rst $end
$var wire 1 A temp_zero $end
$var reg 5 B alu_control [4:0] $end
$var reg 32 C es_o_alu_pc [31:0] $end
$var reg 32 D es_o_alu_value [31:0] $end
$var reg 1 E es_o_ce $end
$var reg 1 F es_o_change_pc $end
$var reg 6 G es_o_funct [5:0] $end
$var reg 6 H es_o_opcode [5:0] $end
$var reg 1 I es_o_zero $end
$scope module a $end
$var wire 1 9 a_i_alu_src $end
$var wire 32 J a_i_data_rs [31:0] $end
$var wire 32 K a_i_data_rt [31:0] $end
$var wire 5 L a_i_funct [4:0] $end
$var wire 16 M a_i_imm [15:0] $end
$var wire 32 N a_i_pc [31:0] $end
$var wire 32 O a_imm [31:0] $end
$var wire 32 P a_o_data_2 [31:0] $end
$var wire 1 Q funct_add $end
$var wire 1 R funct_addu $end
$var wire 1 S funct_and $end
$var wire 1 T funct_beq $end
$var wire 1 U funct_bne $end
$var wire 1 V funct_eq $end
$var wire 1 W funct_ge $end
$var wire 1 X funct_geu $end
$var wire 1 Y funct_neq $end
$var wire 1 Z funct_or $end
$var wire 1 [ funct_sll $end
$var wire 1 \ funct_slt $end
$var wire 1 ] funct_sltu $end
$var wire 1 ^ funct_sra $end
$var wire 1 _ funct_srl $end
$var wire 1 ` funct_sub $end
$var wire 1 a funct_xor $end
$var reg 32 b alu_pc [31:0] $end
$var reg 32 c alu_value [31:0] $end
$var reg 1 d done $end
$upscope $end
$upscope $end
$scope task reset $end
$var integer 32 e counter [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10 e
1d
b0 c
b0 b
0a
0`
0_
0^
0]
0\
0[
0Z
0Y
0X
0W
0V
0U
0T
0S
0R
1Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
0I
b0 H
b0 G
0F
0E
b0 D
b0 C
b0 B
1A
0@
b0 ?
b0 >
b0 =
b0 <
0;
0:
09
b0 8
b0 7
06
15
b0 4
b0 3
02
b0 1
b0 0
b0 /
b0 .
0-
0,
0+
b0 *
b0 )
0(
0'
b0 &
b0 %
0$
0#
b0 "
b0 !
$end
#5
1(
16
#10
0(
06
#15
12
1@
1(
16
#20
0(
06
#25
1E
1#
1I
1'
b100000 G
b100000 %
0A
b100 P
b1001 c
b1001 4
1d
15
b100000 )
b100000 7
b100 /
b100 =
b100 K
b101 .
b101 <
b101 J
b1010 0
b1010 >
b1010 M
b1010 O
b1010 1
b1010 ?
b1010 N
1-
1;
1(
16
#30
0(
06
#35
0I
0'
b100001 G
b100001 %
b1001 D
b1001 "
1d
15
b1 c
b1 4
b1 B
b1 L
0Q
1`
b100001 )
b100001 7
1(
16
#40
0(
06
#45
b1010 C
b1010 !
b101110 G
b101110 %
b11 H
b11 &
b1 D
b1 "
1A
b1010000 b
b1010000 3
1T
b1111 B
b1111 L
0Q
0`
1d
15
b0 c
b0 4
b1010 P
b11 *
b11 8
b101110 )
b101110 7
b101 /
b101 =
b101 K
1,
1:
1+
19
1(
16
#50
0(
06
#55
1F
1$
b1010000 C
b1010000 !
1I
1'
b0 D
b0 "
1(
16
#60
0(
06
#65
1(
16
#70
0(
06
#75
1(
16
